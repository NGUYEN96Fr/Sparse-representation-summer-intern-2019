function [ opts ] = jonswap_simu(dico,gam,range, freq, theta)

% The code simulates the directional wave spectra modeled as follow:
%       S(w,theta) = S(w)*G(theta)
%   where:  S(w,theta) is the directional wave spectrum [1]. 
%           S(w) is the JONSWAP type frequency spectrum.
%           G(theta) is the Misuyasu-type spreading function.
%
% Inputs:
%   disco: type of the atom.
%   gam - the shape parameter of the JONSWAP type frequency spectrum.
%   range - the range of the estimated parameters shown as follow:
%           range(:,:,1) =[Hmin Tmin ; Hmax Tmax]
%           range(:,:,2) =[cmin theta0min; cmax theta0max]
%           + H: the significant wave height (1/3 of the highest wave).
%           + T: the significant wave period (1/3 of the longest period).
%           + c: the Misuyasu-type spreading function's parameter.
%           + theta0: the mean wave direction
%
% Reference:
% [1] Krzysztof Podorski, Igor Rychilik, Ulla E.B.Machado,
% "Exact disitribution for apparent waves in irregular seas".
%
% Written by: Van-Khoa NGUYEN
% Email: van-khoa.nguyen@imt-atlantique.net
% Created: August 2019.

switch dico
    case 'jonswap'
        p_range = range;
        epsilon = 0.2;
        %freq = linspace(0,10,100); % the frequency range
        %theta = linspace(0,2*pi,36); % the theta range
        min_freq = min(freq);
        max_freq = max(freq);
        freq_len = length(freq);
        theta_len = length(theta);
        
        freq_ = (max(0.1,min_freq-epsilon)):(max_freq+epsilon-max(0.1,min_freq-epsilon))/(freq_len-1):(max_freq+epsilon);
        theta_ = 0:2*pi/(theta_len -1):2*pi;
        theta_ = mod(-pi/2-theta_,2*pi);
        [ffreq,ttheta] = meshgrid(freq_,theta_);
        
        atom = @(param) atom_jonswap(param, ffreq, ttheta, gam);
        datom = @(param) datom_jonswap(param, ffreq, ttheta, gam);
        cplx = false;
        simu = @(k,SNR) signal(k,SNR,p_range,atom,cplx);
end

opts.cplx= cplx;
opts.range = p_range;
opts.atom = atom;
opts.datom = datom;
opts.simu = simu;
opts.test_grid = @(N) make_grid(N,p_range);

end


function [ A ] = atom_jonswap(param, w, theta, gam)

% the atom generates the JONSWAP directional occean wave spectrum.
%
% param - a matrix containing values of estimated parameters(H, T, c, theta0)
% param = [H1 .. Hn; T1 .. Tn; c1 .. cn; theta01 .. thetha0n]
% w - range of considered frequencies.
% theta - range of considered wave directions.
% gam - the JONSWAP-type's parameter.

len = size(param);
param_len = len(2);
% a dictionary containing the spectra generated by the atom.
atom_dict = [];

for i = 1:param_len
        
    hi = param(1,i); %the ith significant wave height.
    
    ti = param(2,i); %the ith significant wave period.
   
    ci = param(3,i);  %the ith Misuyasu spreading function's parameter.

    theta0i = param(4,i);  %the ith mean wave direction.
    
    betaj = 0.06238*(1.094-0.01915*log(gam))/(0.23+0.0336*gam-0.185*((1.9+gam)^-1));
    
    wp =2*pi*(1-0.132*((gam+0.2)^-0.559))/ti;     % the peak frequency.
    
    alpha = betaj*(hi^2)*(wp^4);   % the Phillips constants
    
    sigma = (w/wp >1)*0.09 +(w/wp <= 1)*0.07;
    
    kwp = -((w-wp).^2)./(2*(sigma.^2)*(wp^2));
    
    mwp = exp(kwp);
    
    gwp = gam.^mwp;
    
    fwp = (1./(w.^5)).*exp(-1.25*((wp./w).^4));
    %   range - the range of the estimated parameters shown as follow:
%           range(:,:,1) =[Hmin Tmin ; Hmax Tmax]
%           range(:,:,2) =[cmin theta0min; cmin theta0min]
    % the JONSWAP frequency spectrum.
    Sw = alpha.*gwp.*fwp;
    
    % the Misuyasu spreading function's normalization constant.
    fun = @(x) (cos((mod(-x-pi/2,2*pi)-theta0i)./2)).^(2*ci);
    G0 = 1/(integral(fun,0,2*pi));
    
    % the Misuyasu spreading function
    Gtheta = G0*((cos((theta-theta0i)./2)).^(2*ci));
    
    % the directional wave spectrum
    Swtheta = Sw.*Gtheta;
    
    % Add to the dictionary
    atom_dict =[atom_dict, reshape(Swtheta,[],1)];
end

A = atom_dict;

end


function [ dA ] = datom_jonswap(param, w, theta, gam)

% the atom generates the JONSWAP directional wave spectrum.
%
% param - a matrix containing values of estimated parameters(H, T, c, theta0)
% param = [H1 .. Hn; T1 .. Tn; c1 .. cn; theta01 .. thetha0n]
% w - range of considered frequencies.
% theta - range of considered wave directions.
% gam - the JONSWAP-type's parameter.

len = size(param);
param_len = len(2);
% a dictionary containing the spectra generated by the derivative of the atom.
datom_dict = [];

for i= 1:param_len
            
    hi = param(1,i  ); % the ith significant wave height.
    
    ti = param(2,i); % the ith significant wave period.
   
    ci = param(3,i);  % the ith Misuyasu spreading function's parameter.

    theta0i = param(4,i);  %the ith mean wave direction.
    
    betaj = 0.06238*(1.094-0.01915*log(gam))/(0.23+0.0336*gam-0.185*((1.9+gam)^-1));
    
    wp =2*pi*(1-0.132*((gam+0.2)^-0.559))/ti;     % the peak frequency.
    
    dwp_T = -(1/ti)*wp; % the derivative of the wp peak frequency with respect to T (the significant wave period).
    
    sigma = (w/wp >1)*0.09 +(w/wp <= 1)*0.07;
    
    kwp = -((w-wp).^2)./(2*(sigma.^2)*(wp^2));
    
    dkwp_wp =(1./((sigma.^2).*(wp.^3))).*(w.^2 -w.*wp); 
    
    mwp = exp(kwp);
    
    dmwp_wp = mwp.*dkwp_wp;
    
    gwp = gam.^mwp;
    
    dgwp_wp = log(gam).*gwp.*dmwp_wp; % the derivative of the gwp function with respect to the peak frequency (wp).
    
    fwp = (1./(w.^5)).*exp(-1.25*((wp./w).^4));
    
    dfwp_wp = (-5*(wp.^3)./(w.^4)).*fwp;
    
    alpha = betaj*(hi^2)*(wp^4);   % the Phillips constants
    
    dalpha_wp = 4*alpha./wp;
    
    fun = @(x) (cos((mod(-x-pi/2,2*pi)-theta0i)./2)).^(2*ci);
    G0 = 1/(integral(fun,0,2*pi)); % the Misuyasu spreading function's normalization constant.
    
    G_theta = G0*((cos((theta-theta0i)./2)).^(2*ci)); % the Misuyasu spreading function
    
    % The derivative of the JONSWAP frequency spectrum with respect to the
    % peak frequency.
    dSw_wp = (dalpha_wp.*fwp + dfwp_wp.*alpha).*gwp + alpha.*fwp.*dgwp_wp;
    
    % The derivative of the directional wave spectrum with respect to the
    % significant wave period.
    dSwtheta_T = dSw_wp.*dwp_T.*G_theta;
    
    dalpha_H = (2/hi)*alpha;
    
    % The derivative of the directional wave spectrum with respect to the
    % significant wave height.
    dSwtheta_H = dalpha_H.*fwp.*gwp.*G_theta;
    
    Sw = alpha.*gwp.*fwp; % the JONSWAP frequency spectrum.
    
    % the derivative of the Misuyasu spreading function with respect to the
    % c parameter.
    %k = (0 <= theta0i <= pi/2)*0 + (pi/2 < theta0i <= pi)*1 + (pi < theta0i <= 3*pi/2)*2 + (3*pi/2 < theta0i <=2*pi)*3;
    %theta_new = mod(theta,pi/2) +k*(pi/2);
    %dGtheta_c =2.*G0.*log(cos((theta - theta0i)./2)+((abs(theta_new - theta0i)./2) <= pi/72));
    dGtheta_c = 2.*G_theta.*log(cos((theta - theta0i)./2));
    
    
    % the derivative of the directional wave spectrum with respect to the
    % c Misuyasu spreading function parameter.
    dSwtheta_c = Sw.*dGtheta_c;
    
    
    dGtheta_theta0 = G0.*ci.*((cos((theta-theta0i)./2)).^(2*ci -1)).*sin((theta-theta0i)./2);
    
    % the derivative of the directional wave spectrum with respect to the
    % mean wave direction.
    dSwtheta_theta0 = Sw.*dGtheta_theta0;
    
    dSwtheta = [reshape(dSwtheta_H,[],1), reshape(dSwtheta_T,[],1), reshape(dSwtheta_c,[],1), reshape(dSwtheta_theta0,[],1)];
    
    datom_dict = [datom_dict dSwtheta];
    
end

dA = datom_dict;

end


function [G] = make_grid(N,p_range)

% Make grids for the parameters
% 
% N = [N_H, N_T, N_c, N_theta0]
% a row vector contains a number of elements of each corresponding parameters.
%
%   p_range - the range of the estimated parameters shown as follow:
%           p_range(:,:,1) =[Hmin Tmin ; Hmax Tmax]
%           p_range(:,:,2) =[cmin theta0min; cmin theta0min]

gH = p_range(1,1,1):(p_range(2,1,1)-p_range(1,1,1))/(N(1,1)-1):p_range(2,1,1);
gH_ = gH(randperm(length(gH)));
gT = p_range(1,2,1):(p_range(2,2,1)-p_range(1,2,1))/(N(1,2)-1):p_range(2,2,1);
gT_ = gT(randperm(length(gT)));
gc = p_range(1,1,2):(p_range(2,1,2)-p_range(1,1,2))/(N(1,3)-1):p_range(2,1,2);
gc_ = gc(randperm(length(gc)));
gtheta0 = p_range(1,2,2):(p_range(2,2,2)-p_range(1,2,2))/(N(1,4)-1):p_range(2,2,2);
gtheta0_ = gtheta0(randperm(length(gtheta0)));
%gtheta0 = mod(-pi/2-gtheta,2*pi);

[H, T, c, theta0] = ndgrid(gH_, gT_, gc_, gtheta0_);
H_ = H(randperm(length(H)));
T_ = T(randperm(length(T)));
c_ = c(randperm(length(c)));
theta0_ = theta0(randperm(length(theta0)));

G = [reshape(H_,1,[]);reshape(T_,1,[]);reshape(c_,1,[]);reshape(theta0_,1,[])];

end


function [param,coeff,y] = signal(k,SNR,p_range,atom,cplx)

pH = rand(1,k)*(p_range(2,1,1)-p_range(1,1,1))+p_range(1,1,1);
pT = rand(1,k)*(p_range(2,2,1)-p_range(1,2,1))+p_range(1,2,1);
pc = rand(1,k)*(p_range(2,1,2)-p_range(1,1,2))+p_range(1,1,2);
ptheta = rand(1,k)*(p_range(2,2,2)-p_range(1,2,2))+p_range(1,2,2);
ptheta0 = mod(-pi/2-ptheta,2*pi);

param = [pH; pT; pc; ptheta0];

if(cplx)
    coeff = randn(k,1)+1i*randn(k,1);
else
    coeff = randn(k,1) + 2;
end

y = atom(param)*coeff;
n = randn(size(y));
n = n/norm(n)*norm(y)*10^(-SNR/20);
y=y+n;

end